-- =============================================
-- SISTEMA COMPLETO DO OLHO GIGANTE - BALADA
-- =============================================

print("=== SISTEMA DO OLHO GIGANTE ===")

-- Pega TODAS as telas (seu código que funciona)
local telas = {peripheral.find("monitor")}
if not telas[1] then telas = {telas} end

print("Telas detectadas: " .. #telas)

-- Configura todas as telas (seu código)
for i, tela in ipairs(telas) do
    tela.setTextScale(0.5)
    tela.setBackgroundColor(colors.black)
    tela.clear()
end

-- Sistema do Olho
local larguraTotal, alturaTotal = 0, 0
local tempo = 0

-- Organizar telas em grid automático
function organizarTelas()
    print("Organizando telas em grid...")
    
    -- Configurações de tamanho (baseado no textScale 0.5)
    local larguraTela, alturaTela = 8, 5  -- Tamanho padrão com textScale 0.5
    
    -- Calcular grid para todas as telas
    local xAtual, yAtual = 1, 1
    local telasPorLinha = math.ceil(math.sqrt(#telas))
    local maxAlturaLinha = 0
    
    for i, tela in ipairs(telas) do
        -- Atribuir posição no grid gigante
        tela.posX = xAtual
        tela.posY = yAtual
        tela.largura = larguraTela
        tela.altura = alturaTela
        
        -- Atualizar tamanho total
        larguraTotal = math.max(larguraTotal, xAtual + larguraTela - 1)
        alturaTotal = math.max(alturaTotal, yAtual + alturaTela - 1)
        maxAlturaLinha = math.max(maxAlturaLinha, alturaTela)
        
        -- Mover para próxima posição
        xAtual = xAtual + larguraTela + 1  -- +1 para espaçamento
        
        -- Quebra de linha
        if i % telasPorLinha == 0 then
            xAtual = 1
            yAtual = yAtual + maxAlturaLinha + 1
            maxAlturaLinha = 0
        end
    end
    
    print("Tela gigante criada: " .. larguraTotal .. "x" .. alturaTotal)
    print("Grid: " .. telasPorLinha .. " telas por linha")
end

-- Limpar TODAS as telas
function limparTodasTelas()
    for i, tela in ipairs(telas) do
        tela.setBackgroundColor(colors.black)
        tela.clear()
    end
end

-- Desenhar pixel em coordenada global da tela gigante
function desenharPixel(xGlobal, yGlobal, cor)
    for i, tela in ipairs(telas) do
        -- Verificar se esta tela contém estas coordenadas globais
        if xGlobal >= tela.posX and xGlobal < tela.posX + tela.largura and
           yGlobal >= tela.posY and yGlobal < tela.posY + tela.altura then
            
            -- Converter coordenada global para local da tela
            local xLocal = xGlobal - tela.posX + 1
            local yLocal = yGlobal - tela.posY + 1
            
            -- Desenhar na tela
            tela.setBackgroundColor(cor)
            tela.setCursorPos(xLocal, yLocal)
            tela.write(" ")
            return true
        end
    end
    return false
end

-- Desenhar o olho completo em posição global
function desenharOlho(xGlobal, yGlobal)
    -- Limpar tudo primeiro
    limparTodasTelas()
    
    -- Desenhar parte branca do olho (formato oval)
    for x = -4, 4 do
        for y = -3, 3 do
            -- Fórmula de elipse para formato de olho
            if (x*x)/(4*4) + (y*y)/(3*3) <= 1 then
                desenharPixel(xGlobal + x, yGlobal + y, colors.white)
            end
        end
    end
    
    -- Desenhar íris (parte colorida)
    for x = -2, 2 do
        for y = -1, 1 do
            if (x*x)/(2*2) + (y*y)/(1*1) <= 1 then
                desenharPixel(xGlobal + x, yGlobal + y, colors.blue)
            end
        end
    end
    
    -- Desenhar pupila
    for x = -1, 1 do
        for y = -1, 1 do
            if math.abs(x) + math.abs(y) <= 1 then
                desenharPixel(xGlobal + x, yGlobal + y, colors.black)
            end
        end
    end
    
    -- Desenhar brilho no olho
    desenharPixel(xGlobal - 1, yGlobal - 1, colors.lightBlue)
    desenharPixel(xGlobal, yGlobal - 1, colors.white)
end

-- Desenhar olho alternativo (mais estilizado)
function desenharOlhoEstilizado(xGlobal, yGlobal)
    limparTodasTelas()
    
    -- Olho mais detalhado
    local function dentroElipse(x, y, rx, ry)
        return (x*x)/(rx*rx) + (y*y)/(ry*ry) <= 1
    end
    
    -- Branco do olho
    for x = -5, 5 do
        for y = -4, 4 do
            if dentroElipse(x, y, 5, 4) then
                desenharPixel(xGlobal + x, yGlobal + y, colors.white)
            end
        end
    end
    
    -- Íris azul
    for x = -3, 3 do
        for y = -2, 2 do
            if dentroElipse(x, y, 3, 2) then
                desenharPixel(xGlobal + x, yGlobal + y, colors.blue)
            end
        end
    end
    
    -- Pupila preta
    for x = -2, 2 do
        for y = -1, 1 do
            if dentroElipse(x, y, 2, 1) then
                desenharPixel(xGlobal + x, yGlobal + y, colors.black)
            end
        end
    end
    
    -- Brilhos realistas
    desenharPixel(xGlobal - 2, yGlobal - 1, colors.lightBlue)
    desenharPixel(xGlobal - 1, yGlobal - 2, colors.lightBlue)
    desenharPixel(xGlobal + 1, yGlobal - 1, colors.white)
end

-- Movimento do olho pela tela gigante
function movimentoCircular(t)
    local centroX = larguraTotal / 2
    local centroY = alturaTotal / 2
    
    -- Movimento circular suave
    local raio = math.min(centroX, centroY) - 6
    local x = centroX + math.cos(t * 0.8) * raio * 0.8
    local y = centroY + math.sin(t * 1.2) * raio * 0.6
    
    -- Adicionar tremor sutil para parecer mais natural
    x = x + math.sin(t * 5) * 0.5
    y = y + math.cos(t * 4) * 0.3
    
    return math.floor(x), math.floor(y)
end

function movimentoEspiral(t)
    local centroX = larguraTotal / 2
    local centroY = alturaTotal / 2
    
    -- Movimento em espiral expansiva
    local raio = (t % 15) * 1.5
    local x = centroX + math.cos(t) * raio
    local y = centroY + math.sin(t * 1.5) * (raio * 0.7)
    
    return math.floor(x), math.floor(y)
end

function movimentoAleatorio(t)
    -- Movimento pseudo-aleatório suave
    local x = (math.sin(t * 0.3) * 0.5 + 0.5) * (larguraTotal - 10) + 5
    local y = (math.cos(t * 0.4) * 0.5 + 0.5) * (alturaTotal - 8) + 4
    
    return math.floor(x), math.floor(y)
end

function movimentoZigueZague(t)
    -- Movimento em zigue-zague
    local x = (t * 2) % (larguraTotal - 8) + 4
    local y = alturaTotal / 2 + math.sin(t * 3) * (alturaTotal / 3 - 3)
    
    return math.floor(x), math.floor(y)
end

-- Animação principal
function executarAnimacao()
    local modosMovimento = {
        movimentoCircular,
        movimentoEspiral, 
        movimentoAleatorio,
        movimentoZigueZague
    }
    
    local nomesModos = {
        "Circular Suave",
        "Espiral Expansiva",
        "Aleatório Natural", 
        "Zigue-Zague Dinâmico"
    }
    
    local modoAtual = 1
    local ultimaTroca = os.time()
    
    print("\n=== ANIMAÇÃO INICIADA ===")
    print("Pressione Ctrl+T para parar")
    print("Modos alternam a cada 25 segundos")
    print("==========================\n")
    
    while true do
        -- Trocar modo de movimento a cada 25 segundos
        if os.time() - ultimaTroca > 25 then
            modoAtual = (modoAtual % #modosMovimento) + 1
            ultimaTroca = os.time()
            print("Modo alterado: " .. nomesModos[modoAtual])
        end
        
        -- Calcular posição do olho
        local x, y = modosMovimento[modoAtual](tempo)
        
        -- Garantir que está dentro dos limites
        x = math.max(6, math.min(larguraTotal - 5, x))
        y = math.max(5, math.min(alturaTotal - 4, y))
        
        -- Alternar entre os dois estilos de olho
        if math.sin(tempo * 2) > 0 then
            desenharOlho(x, y)
        else
            desenharOlhoEstilizado(x, y)
        end
        
        -- Atualizar tempo e esperar
        tempo = tempo + 0.12
        os.sleep(0.18)  -- Velocidade da animação
    end
end

-- Mostrar informações do sistema
function mostrarInfo()
    print("\n=== CONFIGURAÇÃO DO SISTEMA ===")
    print("Telas detectadas: " .. #telas)
    print("Resolução total: " .. larguraTotal .. "x" .. alturaTotal)
    print("\nModos de movimento:")
    for i, nome in ipairs(nomesModos) do
        print(i .. ". " .. nome)
    end
    print("\nO olho passará por TODAS as telas!")
    print("===================================")
end

-- Programa principal
local function main()
    if #telas == 0 then
        print("ERRO: Nenhuma tela detectada!")
        print("Conecte monitores usando:")
        print("  peripheral.find('monitor')")
        return
    end
    
    organizarTelas()
    mostrarInfo()
    executarAnimacao()
end

-- Executar com tratamento de erro
local ok, err = pcall(main)
if not ok then
    print("ERRO: " .. err)
    print("Reiniciando em 3 segundos...")
    os.sleep(3)
    os.reboot()
end
